<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Gesture PDF Controller</title>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.min.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            display: flex;
            margin: 0;
            padding: 20px;
            background-color: #f0f0f0;
        }
        #app-container {
            display: flex;
            max-width: 1200px;
            margin: 0 auto;
            background-color: white;
            box-shadow: 0 0 10px rgba(0,0,0,0.1);
            border-radius: 10px;
            overflow: hidden;
        }
        #video-container {
            width: 400px;
            padding: 10px;
            background-color: #f9f9f9;
        }
        #pdf-container {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 10px;
        }
        #pdf-canvas {
            max-width: 800px;
            max-height: 800px;
            border: 1px solid #ddd;
            background-color: white;
        }
        #status-label, #page-label {
            margin: 10px 0;
            text-align: center;
        }
        #webcam-video, #hand-canvas {
            width: 100%;
            transform: scaleX(-1);
        }
        #pointer {
            position: absolute;
            pointer-events: none;
            z-index: 10;
        }
    </style>
</head>
<body>
    <div id="app-container">
        <div id="video-container">
            <video id="webcam-video" width="400" height="400"></video>
            <canvas id="hand-canvas" width="400" height="400"></canvas>
            <div id="status-label"></div>
        </div>
        <div id="pdf-container">
            <div id="pointer"></div>
            <canvas id="pdf-canvas" width="800" height="800"></canvas>
            <div id="page-label">No PDF loaded</div>
            <div id="mode-label"></div>
            <input type="file" id="pdf-upload" accept=".pdf">
        </div>
    </div>

    <script>
        // Initialize PDF.js
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.worker.min.js';

        class WebPDFController {
            constructor() {
                 try {
            this.initializeElements();
            this.initializeVariables();
            this.setupHandTracking().catch(error => {
                console.error('Hand tracking setup failed:', error);
                this.statusLabel.textContent = 'Hand tracking setup failed. Check console for details.';
            });
            this.setupEventListeners();
        } catch (error) {
            console.error('Initialization error:', error);
            this.statusLabel.textContent = 'Initialization failed. Check console for details.';
        }
            }

            initializeElements() {
                this.videoElement = document.getElementById('webcam-video');
                this.handCanvas = document.getElementById('hand-canvas');
                this.pdfCanvas = document.getElementById('pdf-canvas');
                this.pdfUpload = document.getElementById('pdf-upload');
                this.statusLabel = document.getElementById('status-label');
                this.pageLabel = document.getElementById('page-label');
                this.modeLabel = document.getElementById('mode-label');
                this.pointerElement = document.getElementById('pointer');
                this.ctx = this.pdfCanvas.getContext('2d');
                this.handCtx = this.handCanvas.getContext('2d');
            }

            initializeVariables() {
                this.pdfDoc = null;
                this.currentPage = 0;
                this.totalPages = 0;
                this.drawingMode = 'none';
                this.lastX = null;
                this.lastY = null;
                this.drawings = {};
                this.penColor = 'red';
                this.penWidth = 2;
                this.eraserWidth = 20;
                this.gestureStartTime = null;
                this.gestureHoldTime = 500; // milliseconds
                this.gestureType = null;
            }

            async setupHandTracking() {
                  try {
            this.hands = new Hands({
                locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
            });

            this.hands.setOptions({
                maxNumHands: 2, // Allow detection of multiple hands
                modelComplexity: 1,
                minDetectionConfidence: 0.5, // Slightly lower threshold
                minTrackingConfidence: 0.5
            });

            this.hands.onResults(this.handleHandResults.bind(this));

            // More comprehensive webcam setup
            const stream = await navigator.mediaDevices.getUserMedia({
                video: {
                    width: { ideal: 640 },
                    height: { ideal: 480 }
                }
            });

            this.videoElement.srcObject = stream;
            this.videoElement.addEventListener('loadedmetadata', () => {
                this.videoElement.play();
                this.startHandTracking();
            });
        } catch (error) {
            console.error('Webcam or hand tracking setup failed:', error);
            this.statusLabel.textContent = 'Failed to access webcam or set up hand tracking.';
            throw error;
        }
            }

            async setupWebcam() {
                const stream = await navigator.mediaDevices.getUserMedia({ video: true });
                this.videoElement.srcObject = stream;
                this.videoElement.play();

                this.videoElement.onloadedmetadata = () => {
                    this.hands.send({ image: this.videoElement });
                };
            }

            startHandTracking() {
                const sendFrame = async () => {
                    if (!this.videoElement.paused) {
                        await this.hands.send({ image: this.videoElement });
                    }
                    requestAnimationFrame(sendFrame);
                };
                sendFrame();
            }

            handleHandResults(results) {
                  this.clearHandCanvas();

        // More comprehensive results handling
        if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
            results.multiHandLandmarks.forEach((landmarks, index) => {
                // Draw landmarks for all detected hands
                this.drawHandLandmarks({ multiHandLandmarks: [landmarks] });

                // Detect gestures for the first hand
                if (index === 0) {
                    this.detectAndHandleGestures(landmarks);
                }
            });

            // Debug logging
            console.log(`Detected ${results.multiHandLandmarks.length} hand(s)`);
        } else {
            // Clear status when no hands detected
            this.statusLabel.textContent = 'No hands detected';
        }
            }

            detectAndHandleGestures(landmarks) {
                const { gesture, isValid } = this.identifyGesture(landmarks);

                if (isValid) {
                    const indexTip = landmarks[8];
                    const indexBase = landmarks[5];

                    if (indexTip.y < indexBase.y) {
                        this.updatePointer(indexTip.x, indexTip.y);
                    }

                    if (gesture === 'pen' || gesture === 'eraser') {
                        this.handleDrawing(landmarks, gesture);
                    } else if (gesture === 'next' || gesture === 'prev') {
                        this.handlePageTurning(gesture);
                    }
                }
            }

            identifyGesture(landmarks) {
                try {
            const tips = [8, 12, 16, 20].map(index => landmarks[index]);
            const bases = [5, 9, 13, 17].map(index => landmarks[index]);
            const wrist = landmarks[0];

            const isUp = tips.map((tip, i) => tip.y < bases[i].y - 0.05);

            const fingersSpread = tips.map((tip, i) =>
                Math.abs(tip.x - bases[i].x) > 0.05 // Check finger spread
            );

            // Debugging gesture detection
            console.log('Finger states:', {
                isUp,
                fingersSpread
            });

            // More precise gesture conditions
            if (isUp[0] && !isUp[1] && !isUp[2] && !isUp[3]) {
                return { gesture: 'pen', isValid: true };
            }
            if (isUp[0] && isUp[1] && !isUp[2] && !isUp[3]) {
                return { gesture: 'eraser', isValid: true };
            }
            if (fingersSpread[0] && fingersSpread[1] && isUp[0] && isUp[1]) {
                return { gesture: 'next', isValid: true };
            }
            if (fingersSpread[2] && fingersSpread[3] && isUp[2] && isUp[3]) {
                return { gesture: 'prev', isValid: true };
            }

            return { gesture: null, isValid: false };
        } catch (error) {
            console.error('Gesture identification error:', error);
            return { gesture: null, isValid: false };
        }
            }

            handleDrawing(landmarks, mode) {
                const indexTip = landmarks[8];
                const canvasX = indexTip.x * this.pdfCanvas.width;
                const canvasY = indexTip.y * this.pdfCanvas.height;

                this.ctx.strokeStyle = mode === 'pen' ? this.penColor : 'white';
                this.ctx.lineWidth = mode === 'pen' ? this.penWidth : this.eraserWidth;
                this.ctx.lineCap = 'round';

                if (this.lastX !== null && this.lastY !== null) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(this.lastX, this.lastY);
                    this.ctx.lineTo(canvasX, canvasY);
                    this.ctx.stroke();
                }

                this.lastX = canvasX;
                this.lastY = canvasY;
                this.drawingMode = mode;
                this.updateModeLabel(mode);
            }

            handlePageTurning(gesture) {
                if (!this.pdfDoc) return;

                const now = Date.now();
                if (!this.gestureStartTime) {
                    this.gestureStartTime = now;
                    this.gestureType = gesture;
                }

                const holdDuration = now - this.gestureStartTime;
                if (holdDuration >= this.gestureHoldTime) {
                    if (gesture === 'next' && this.currentPage < this.totalPages - 1) {
                        this.currentPage++;
                        this.renderPDFPage();
                    } else if (gesture === 'prev' && this.currentPage > 0) {
                        this.currentPage--;
                        this.renderPDFPage();
                    }
                    this.gestureStartTime = null;
                }
            }

            updateModeLabel(mode) {
                this.modeLabel.textContent = `Mode: ${mode.charAt(0).toUpperCase() + mode.slice(1)}`;
            }

            updatePointer(x, y) {
                const pointerSize = 10;
                this.pointerElement.style.display = 'block';
                this.pointerElement.style.left = `${x * 100}%`;
                this.pointerElement.style.top = `${y * 100}%`;
                this.pointerElement.style.width = `${pointerSize}px`;
                this.pointerElement.style.height = `${pointerSize}px`;
                this.pointerElement.style.backgroundColor = 'black';
                this.pointerElement.style.position = 'absolute';
                this.pointerElement.style.transform = 'translate(-50%, -50%)';
                this.pointerElement.style.borderRadius = '50%';
            }

            clearHandCanvas() {
                this.handCtx.clearRect(0, 0, this.handCanvas.width, this.handCanvas.height);
            }

            drawHandLandmarks(results) {
                if (results.multiHandLandmarks) {
                    for (const landmarks of results.multiHandLandmarks) {
                        drawConnectors(this.handCtx, landmarks, HAND_CONNECTIONS, {
                            color: '#00FF00',
                            lineWidth: 5
                        });
                        drawLandmarks(this.handCtx, landmarks, {
                            color: '#FF0000',
                            lineWidth: 2
                        });
                    }
                }
            }

            setupEventListeners() {
                this.pdfUpload.addEventListener('change', this.loadPDF.bind(this));
            }

            async loadPDF(event) {
                const file = event.target.files[0];
                if (file) {
                    try {
                        const fileReader = new FileReader();
                        fileReader.onload = async (e) => {
                            const typedarray = new Uint8Array(e.target.result);
                            this.pdfDoc = await pdfjsLib.getDocument({ data: typedarray }).promise;
                            this.totalPages = this.pdfDoc.numPages;
                            this.currentPage = 1;
                            this.renderPDFPage();
                        };
                        fileReader.readAsArrayBuffer(file);
                    } catch (error) {
                        console.error('Error loading PDF:', error);
                        alert('Failed to load PDF. Please try again.');
                    }
                }
            }

            async renderPDFPage() {
                if (!this.pdfDoc) return;

                try {
                    const page = await this.pdfDoc.getPage(this.currentPage);
                    const viewport = page.getViewport({ scale: 1.5 });

                    this.ctx.clearRect(0, 0, this.pdfCanvas.width, this.pdfCanvas.height);

                    const renderContext = {
                        canvasContext: this.ctx,
                        viewport: viewport
                    };

                    await page.render(renderContext).promise;

                    // Update page label
                    this.pageLabel.textContent = `Page: ${this.currentPage} / ${this.totalPages}`;
                } catch (error) {
                    console.error('Error rendering PDF page:', error);
                }
            }
        }

        // Initialize the application when the page loads
        window.addEventListener('load', () => {
            new WebPDFController();
        });
    </script>
</body>
</html>